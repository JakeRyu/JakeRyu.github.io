{"componentChunkName":"component---src-templates-post-js","path":"/api-버전관리/","result":{"data":{"markdownRemark":{"html":"<p>API를 관리하면서 기능 향상이나 추가는 일상적인 요구사항이다. 이때, 기존 호환성을 유지해야 한다면 각기 다른 버전의 API를 제공할 필요가 있다. 마이크로소프트는 <code>Microsoft.AspNetCore.Mvc.Versioning</code> 패키지를 통해 ASP.NET Core의 REST API 버전을 쉽게 관리할 수 있도록 도와준다.</p>\n<!--more-->\n<h2>설정하기</h2>\n<p>패키지를 설치한 후, <code>Startup.cs</code> 에서 기본적인 행동패턴을 설정하자.</p>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">// Startup.cs\r\nservices.AddApiVersioning(config =&gt;\r\n{\r\n    config.DefaultApiVersion = new ApiVersion(1, 0);\r\n    config.AssumeDefaultVersionWhenUnspecified = true;\r\n    config.ReportApiVersions = true;\r\n    config.ApiVersionReader = new HeaderApiVersionReader(&quot;X-Version&quot;);\r\n});</code>\n        </deckgo-highlight-code>\n<p><code>AssumeDefaultVersionWhenUnspecified</code> 속성을 <code>true</code>로 활성화하면, 클라이언트 요청에 버전 정보가 없을 경우, 기본 버전을 사용하도록 해준다. 이미 상당수의 API를 개발한 후 버전관리를 시작할 때 유용하다. <code>ReportApiVersions</code> 속성은 아래 그림과 같이 서버에서 제공하고 있는 API 버전을 보여준다. 응답 헤더에 <code>api-supported-verions</code>가 추가된 걸 확인할 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ffa0ce9fe54c2c9f35232f8fd5b860b8/e2d3b/api-supported-versions.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAvUlEQVQoz4WR0QrDIAxF+/8/ORjsZTA6NcZoa++4GV3LWDshGMrx5GqHGCOSCCQ88bheEO43ZEng92qGaZrQWvNin1JC1IRkglIL1BTZFKLZ94GQ5IxlWd7V+9Z/FReFRRVTa7BiMDMsfWOG3jtyziilYJ5nP3QmJBdCQEzRe1bfhXAhp47j6DsT/5Kth0TEhXyCde05F64Q4/c/V17ZI8aFqopa6yG0F5Ll4KOn+Qj5Vzmd/VlKDuZ1jxK+ALQ2Jn6lfB/fAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"api-supported-versions.png\"\n        title=\"api-supported-versions.png\"\n        src=\"/static/ffa0ce9fe54c2c9f35232f8fd5b860b8/5a190/api-supported-versions.png\"\n        srcset=\"/static/ffa0ce9fe54c2c9f35232f8fd5b860b8/772e8/api-supported-versions.png 200w,\n/static/ffa0ce9fe54c2c9f35232f8fd5b860b8/e17e5/api-supported-versions.png 400w,\n/static/ffa0ce9fe54c2c9f35232f8fd5b860b8/5a190/api-supported-versions.png 800w,\n/static/ffa0ce9fe54c2c9f35232f8fd5b860b8/c1b63/api-supported-versions.png 1200w,\n/static/ffa0ce9fe54c2c9f35232f8fd5b860b8/e2d3b/api-supported-versions.png 1466w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>위 설정에서는 헤더에서 버전정보를 읽도록 <code>HeaderApiVersionReader</code>를 사용했지만, 시나리오에 맞추어 <code>ApiVersionReader</code> 속성을 다르게 지정한다.</p>\n<h2>버전 지정하기</h2>\n<p>클라이언트가 버전을 지정하여 요청하면, 그 요청은 해당하는 컨트롤러와 액션으로 리다이렉트된다. 컨트롤러와 액션에 버전을 지정하는 방식에는 여러 접근법이 있다.</p>\n<p>먼저, 버전에 따라 각각의 컨트롤러를 생성할 수 있지만, 아래 예시처럼 컨트롤러 하나에서 여러 버전을 관리할 수도 있다. 만약에 같은 컨트롤에서 여러 버전을 관리한다면 <code>[MpaToApiVersion]</code> 어트리뷰트를 통해 액션별로 버전을 매핑해야 한다.</p>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">[ApiVersion(&quot;1.0&quot;)]\r\n[ApiVersion(&quot;1.1&quot;)]\r\n[ApiController]\r\n[Route(&quot;[controller]&quot;)]\r\npublic class JakeController : ControllerBase\r\n{\r\n    [HttpGet(&quot;{id}&quot;)]\r\n    [MapToApiVersion(&quot;1.0&quot;)]\r\n    public async Task&lt;IActionResult&gt; Get(int id)\r\n    {\r\n        var command = new GetJakeCommand {Id = id};\r\n        var result = await mediator.Send(command);\r\n\r\n        return Ok(result);\r\n    }\r\n\r\n    [HttpGet(&quot;{id}&quot;)]\r\n    [MapToApiVersion(&quot;1.1&quot;)]\r\n    public async Task&lt;IActionResult&gt; GetV1_1(int id)\r\n    {\r\n        var command = new GetJakeCommand {Id = id};\r\n        var result = await mediator.Send(command);\r\n\r\n        return Ok(result);\r\n    }\r\n}</code>\n        </deckgo-highlight-code>\n<p>만약, <code>MapToApiVersion</code> 어트리뷰트가 없다면 앞서 설정한 기본 버전을 사용하는 것으로 간주한다. 그래서 <code>Get</code> 메서드를 수식하는 <code>[MapToApiVersion(\"1.0\")]</code>을 생략할 수도 있다.\r\n실제 운영에는 문제가 없지만 Swagger UI를 사용할 때, 문제가 되므로 명시적으로 매핑 어트리뷰트를 유지하는 것이 좋다.</p>\n<h2>버전관리 방법</h2>\n<p>버전관리에는 네가지 방법이 있다. 또한, 그중 몇가지를 섞어서 사용하는 방법도 가능하다. 선택한 방식에 따라 클라이언트에서 요청을 만드는 방식이 달라지고 서버에서도 대응하는 설정을 해야한다.</p>\n<h3>쿼리 스트링</h3>\n<p>쿼리 파라미터를 사용하는 것이 기본 값이다. 파라미터 명은 <code>api-version</code>이고 다음과 같이 사용한다.</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">https://{domain}/api/controller?api-version=1.1</code>\n        </deckgo-highlight-code>\n<p>기본 값이라 별도 설정이 필요 없지만 명시적인 방식을 선호한다면 다음과 같이 설정한다.</p>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">config.ApiVersionReader = new QueryStringApiVersionReader();</code>\n        </deckgo-highlight-code>\n<p>URL이 지저분해지는 단점이 있지만 가장 간단하고 직관적인 방법이다.</p>\n<h3>요청 헤더</h3>\n<p>클라이언트에서 요청을 만들때, 사용자 헤더를 사용하여 버전을 지정한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/146c95f012509e4a1d109c17d7da048d/1c1a4/x-version.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsElEQVQY021PXQuDMBDr//9/gm9DGKMP2mprq/2wGTlQcLMQmiO53J1a1xXLsiClBO+9cGLfdxhjoLWG8bPU1lrEGMEe8nme5d+2TXoJFULANE3S4JyTkMV51C0gfgb49wtRDyjOYk8JJWfknCXkRClFFiIUC05kIEVyCrfXgNaagP7jOO5yaxdXtVZZlYG/phsA0DuO4+X987QG1fc9uq4DT+fJnE48mRnI7Z+0M/ALxyOGFjTFrtUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"x-version\"\n        title=\"x-version\"\n        src=\"/static/146c95f012509e4a1d109c17d7da048d/5a190/x-version.png\"\n        srcset=\"/static/146c95f012509e4a1d109c17d7da048d/772e8/x-version.png 200w,\n/static/146c95f012509e4a1d109c17d7da048d/e17e5/x-version.png 400w,\n/static/146c95f012509e4a1d109c17d7da048d/5a190/x-version.png 800w,\n/static/146c95f012509e4a1d109c17d7da048d/1c1a4/x-version.png 1046w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>사용자 헤더명을 서버 설정에서 정의한다.</p>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">config.ApiVersionReader = new HeaderApiVersionReader(&quot;X-Version&quot;);</code>\n        </deckgo-highlight-code>\n<p>버전이 숨어 있어 직관적이지 않지만 URL을 조작하지 않아도 되기 때문에 가장 선호되는 방식이다.</p>\n<h3>Accept 헤더 재사용 (미디어 타입)</h3>\n<p>Accept 헤더는 클라이언트가 서버에게 어떤 미디어를 (모든 미디어 <code>*.*</code> 또는 <code>application/json</code> 처럼 특정 미디어) 원하는지 알릴때 사용한다. 사용자 헤더를 따로 정의하지 않고 아래와 같이 Accept 헤더를 재사용한다.</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">GET /resource/4\r\nAccept: application/json;v=1.1</code>\n        </deckgo-highlight-code>\n<p>단점이라면 구현만 봤을때, 명확하지 않은 느낌이 있다. 클라이언트에서 구현하는게 용이하지 않을 수도 있다.</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">config.ApiVersionReader = new MediaTypeApiVersionReader();</code>\n        </deckgo-highlight-code>\n<h3>URL 경로</h3>\n<p>URL 경로에 명시적으로 버전을 사용하는 방식이다.</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">https://{domain}/api/v1.1/resource</code>\n        </deckgo-highlight-code>\n<p>리소스(컨트롤러) 앞에 버전이 명시되므로 쿼리 스트링 방식보다도 눈에 더 잘 띈다. API의 버전 변경이 전방위적으로 일어날 때, 모든 리소스의 버전 업그레이드가 동시에 일어나 전체 URL의 버전을 업그레이드하는 상황이 이상적이다. 만약, 버전이 다른 URL을 섞어서 사용한다면 그것이 에러인지 의도적인 것인지 오히려 혼동을 줄 수도 있기 때문이다.</p>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">config.ApiVersionReader = new UrlSegmentApiVersionReader();\r\n\r\n// 컨트롤러에서 라우팅을 변경해야 한다\r\n[Route(&quot;api/v{version:apiVersion}/[controller]&quot;)]</code>\n        </deckgo-highlight-code>\n<h2>멀티 버전 관리</h2>\n<p>위에서 살펴본 네가지 방식을 섞어서 사용하는 것이 가능하다. 기대 이상의 기능을 <code>Microsoft.AspNetCore.Mvc.Versioning</code> 패키지가 제공한다.</p>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">config.ApiVersionReader = ApiVersionReader.Combine(new HeaderApiVersionReader(&quot;X-Version&quot;), new QueryStringApiVersionReader(&quot;api-version&quot;));</code>\n        </deckgo-highlight-code>\n<h2>지원 종료된 버전 알리기</h2>\n<p>서버에서 지원 가능한 API 버전을 응답헤더를 통해 내려 줬듯이 더 이상 지원하지 않는 버전도 설정할 수 있다. 클라이언트에서는 <code>api-deprecated-versions</code> 헤더에 명시된 버전을 사용하지 않도록 유의해야 한다.</p>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">[ApiVersion(&quot;1.0&quot;, Deprecated = true)]\r\n[ApiVersion(&quot;1.1&quot;)]\r\n[ApiController]\r\n[Route(&quot;[controller]&quot;)]\r\npublic class JakeController : ControllerBase\r\n{\r\n   ...\r\n}</code>\n        </deckgo-highlight-code>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c0450fef1b1f5d8f4b191779e40a3107/d7e70/api-deprecated-versions.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAwElEQVQoz41R7QqDMBDr+7/jYH/Gxhj9srVqPzLScUNFNoUQe97FXKqccxiGAWR9v+FxvcCbJ7z30FpjHEcsy4J5njdMcE4HCxsdYoh4DRqqlIIQAsglReTgO9dae428R2ut/zCl1N9bbZ96bVAsUHCaJvBpAjb+AJ1TlC5jjF2DrOQjVxan/8QIDltrIZFRnPNfh2zIOZ8SkxlCopF41Nr+uunsyvv6ZmVCwv4nyts+2qgLMgNjTM+E4PmM4FHPG93tc3ruLzvGAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"api-deprecated-versions\"\n        title=\"api-deprecated-versions\"\n        src=\"/static/c0450fef1b1f5d8f4b191779e40a3107/5a190/api-deprecated-versions.png\"\n        srcset=\"/static/c0450fef1b1f5d8f4b191779e40a3107/772e8/api-deprecated-versions.png 200w,\n/static/c0450fef1b1f5d8f4b191779e40a3107/e17e5/api-deprecated-versions.png 400w,\n/static/c0450fef1b1f5d8f4b191779e40a3107/5a190/api-deprecated-versions.png 800w,\n/static/c0450fef1b1f5d8f4b191779e40a3107/c1b63/api-deprecated-versions.png 1200w,\n/static/c0450fef1b1f5d8f4b191779e40a3107/d7e70/api-deprecated-versions.png 1286w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2>결론</h2>\n<p>이상 네가지 방식을 통해 각기 사용하거나 섞어 쓰는 방식으로 대부분의 시나리오를 만족시킬 수 있을 것 같다. 개인적으로는 사용자 헤더를 사용하는 방식이 깔끔해 보인다. URL을 깨끗하게 유지할 수 있고, 전용 헤더를 사용하기 때문이다. 다만, URL이 서버단 캐싱에 사용된다면, API 버전 업그레이드시 고려해야 할 것이다.</p>","frontmatter":{"title":"API 버전관리","keywords":"api"}}},"pageContext":{"slug":"/api-버전관리/"}},"staticQueryHashes":["3159585216"]}
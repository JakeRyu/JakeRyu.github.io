{"componentChunkName":"component---src-templates-post-js","path":"/제네릭-리포지토리/","result":{"data":{"markdownRemark":{"html":"<p>이전 글, <a href=\"/%EB%A6%AC%ED%8F%AC%EC%A7%80%ED%86%A0%EB%A6%AC-%ED%8C%A8%ED%84%B4\">리포지토리 패턴과 엔티티 프레임워크 코어</a>를 읽고 리포지토리 패턴을 구현하기로 결정했다면 이번 글에서는 엔티티 프레임워크 코어를 활용해서 손쉽게 구현하는 방법을 알아본다. (리포지토리는 정보 저장을 추상화할 때 사용하는 것으로 API를 호출해 다른 곳에 저장하는 것도 그 범주에 둘 수 있지만) 데이터베이스를 사용하는 것이 대부분의 애플리케이션 구성이므로 EF Core를 함께 사용해서 리포지토리 패턴을 구현해 보려고 한다. EF Core 자체가 리포지토리 / 유닛오브워크 패턴을 구현하고 있기 때문에 상당 부분이 델리게이트 형식을 취할 것이고, 코드 반복을 줄이기 위해 제네릭 리포지토리를 사용한다.</p>\n<!--more-->\n<h2>제네릭 리포지토리</h2>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">public interface IRepository&lt;T, I&gt; where T : IEntity where I : struct\r\n{\r\n    Task&lt;T&gt; GetByIdAsync(I id);\r\n    Task AddAsync(T entity);\r\n    void Delete(T entity);\r\n}</code>\n        </deckgo-highlight-code>\n<p>타입 <code>T</code>는 <code>IEntity</code>를 상속하는 클래스여야 하고 <code>I</code>는 int 또는 guild가 될 수 있는 ID 타입이다. <code>IEntity</code>는 <code>Id</code> 속성만을 정의하는데 이는 EF Core가 다루는 엔티티가 되기 위한 기본조건이다.</p>\n<p>리포지토리는 메모리에 존재하는 컬렉션처럼 동작한다. 리스트의 아이템을 개별로 변경하면서 특별히 업데이트라는 메서드를 사용하지 않는 것처럼 리포지토리도 업데이트 기능은 필요없다. 아이템은 변경하려면 일단 ID로 조회하고 그 내용을 변경한다.생성을 포함한 모든 변경 내용은 유닛오브워크가 제공하는 저장 기능을 통해 최종 변경된다. 각각의 리포지토리가 저장 기능을 갖고 있다면 다른 리포지토리와 연계된 변경 내용을 동시 트랜잭션으로 처리할 수 없는 결함이 생긴다.</p>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">public class Repository&lt;T, I&gt; : IRepository&lt;T, I&gt; where T : Entity where I : struct\r\n{\r\n    private readonly ApplicationContext context;\r\n    \r\n    public Repository(ApplicationContext context)\r\n    {\r\n        this.context = context;\r\n    }\r\n    \r\n    public async Task&lt;T&gt; GetByIdAsync(I id)\r\n    {\r\n        var entity = await context.Set&lt;T&gt;().FindAsync(id);\r\n        if(entity == null) throw new EntityNotFoundException(typeof(T).Name, id);\r\n        \r\n        return entity;\r\n    }\r\n\r\n    public async Task AddAsync(T entity) =&gt; await context.Set&lt;T&gt;().AddAsync(entity);\r\n\r\n    public void Delete(T entity) =&gt; context.Set&lt;T&gt;().Remove(entity);\r\n}</code>\n        </deckgo-highlight-code>\n<p><code>Repository</code> 클래스는 <code>IRepository</code> 인터페이스에 대한 기본 구현이며 도메인 엔티티의 부모 클래스 역할을 한다. 생성자를 통해 <code>DbContext</code>를 받고 이 것을 통해 데이터베이스를 조작한다. 앞서 언급한 대로 EF Core의 <code>DbSet</code>에 실행을 위임하고 있기 때문에 래퍼정도로 밖에 보이지 않는다.</p>\n<h2>도메인 리포지토리</h2>\n<p>데이터베이스에 저장되는 도메인 엔티티를 다루기 위해 도메인 리포지토리를 사용한다. 제네릭 리포지토리를 통해 구현한 기능을 상속하므로 기본 기능만으로 충분한 리포지토리라면 특별히 추가할 할 작업이 없다.</p>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">public class Sites : Repository, IDomainRepository\r\n{\r\n}</code>\n        </deckgo-highlight-code>\n<p>아래 다이어그램은 그 관계를 보여주는데 <code>DomainRepository</code>를 보자. 정의는 <code>IDomainRepository</code>를 구현해야 하도록 정의했지만 실제 구현은 <code>Repository</code>를 상속하는 것으로 해결한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/aba3eed301b7ebe6c08f221d7015de13/5df5d/repository-inheritance-hierarchy.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 69%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAABk0lEQVQ4y31T14oCQRC8//8sFRVBBOODCXOcTW401VF99DDuqQ2lzEx3dar9AYDH44Hr9Yrn88mj/PPMez27b59A++GPH4SI4wTT6RTdbhez2QxFUSBN07dBn4zvQhiGIfI8x2AwQLVaRa/XQ5Zl8H3/X9DtdkOSJILdbgdjjCQmbIWHwwGdTkfQ7/exWq0QRRG22y0ul4slYFAQBDidTpK0Uqmg2WxiuVyKnyX0PA/tdhutVkvItTWScI5uy/f7XYLjOMZ+v8f5fJbk7MgS8pEPbJ1t8EyQ8JuxYi7vZYblQTO7btd1LG+ZxqqU8GXLbkus7J1cyn5aIdXgvtkKlaSc8Zts3E5eKjSehyRJsV6vMRwOsdlsZH66OdeCMMLxeMR4PBbf0WgkcZw/JSWE3NZkMpFN12o1kQ6XRGLOiRoVZJnozhgP8/lcPgBC9cju/io0Bo1GA/V6HYvFws5FBU9HgvcUe5HnIh8XvLeEDKQ4WTpb1c+OCyob35mElSvoz/HYljlchVZDMHN522UfBcm45V825jwx3rnTlQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Repository Interface Hierarchy\"\n        title=\"Repository Interface Hierarchy\"\n        src=\"/static/aba3eed301b7ebe6c08f221d7015de13/5a190/repository-inheritance-hierarchy.png\"\n        srcset=\"/static/aba3eed301b7ebe6c08f221d7015de13/772e8/repository-inheritance-hierarchy.png 200w,\n/static/aba3eed301b7ebe6c08f221d7015de13/e17e5/repository-inheritance-hierarchy.png 400w,\n/static/aba3eed301b7ebe6c08f221d7015de13/5a190/repository-inheritance-hierarchy.png 800w,\n/static/aba3eed301b7ebe6c08f221d7015de13/c1b63/repository-inheritance-hierarchy.png 1200w,\n/static/aba3eed301b7ebe6c08f221d7015de13/5df5d/repository-inheritance-hierarchy.png 1572w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><code>IDomainRepository</code> 인터페이스는 제넥릭 리포지토리의 기능을 확장하기 위한 장치다. 애그리게이트 루트를 다룰 때 그 예를 확인할 수 있다. 아래 예는 <code>Site</code>를 다루는 리포지토를 API 컨트롤러에서 사용하는 예다.</p>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">[ApiController]\r\n[Route(&quot;api/[controller]&quot;)]\r\npublic class SiteController : ControllerBase\r\n{\r\n    private readonly IUnitOfWork uow;\r\n\r\n    public SiteController(ILogger&lt;StationController&gt; logger, IUnitOfWork unitOfWork)\r\n    {\r\n        uow = unitOfWork;\r\n    }\r\n\r\n    [HttpGet(&quot;id&quot;)]\r\n    public async Task&lt;IActionResult&gt; Get(int id)\r\n    {\r\n        var sites = await uow.Sites.GetByIdAsync(id);\r\n        \r\n        return Ok(sites);\r\n    }\r\n}</code>\n        </deckgo-highlight-code>\n<p>모든 리포지토리는 유닛오브워크를 통한다. 그래서 생성자에서는 유닛오브워크만 필요하고 이 것은 마치 게이트웨이처럼 모든 리포지토리를 생성없이 사용할 수 있게 해준다.</p>\n<h2>Unit of work</h2>\n<p>조회도 그렇고 변경 내용도 유닛오브워크를 통해 저장한다. 유닛오브워크는 리포지토리의 컨테이너라고 생각할 수 있다. 각 리포지토리의 생성 및 변경 내용을 관리하면서 클라이언트 코드가 필요한 단 하나의 액세스 포인트를 제공한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3cf3c2c84113cd99aeca5ea39731cac1/7970d/unit-of-work.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.49999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABXElEQVQoz5WSW6uCQBSF/f//yB57iEKpkMoLEVEGRV4q75auw9rnjJicC2dg4YzOfLP2cmsA8Hq9kGUZ6roW5Xku7zjatsV/hqaAQRDANE0sFgs8Hg9UVdUBFVTNf1MHDMMQq9UKy+UScRzj+Xy+Oew7Hbrur7WfrA9dcTCOIIxQFAVOpxM2m408y7KUqmhC46YwihFFETzPE91uty7TPryQg4nMGdHxeMT5fBbQ/X6X/RqzStNMbtJ1HaPRCJfLRVxQfSAPuq6L8XiM2WyG3W4n78mgQwE2TYP1eo3pdArDMLDdbiXTNE0lS/5xzglnzizTsizJmnCeV1AB8tbD4SCuaJ/iRwKYzVvJX1CWRzEarq/Xq6gD7vd7uc1xHNi2LS7prt86qhtY5mQykRabz+dyhiYI53eNmwn9TsOWoQNWw4h83xeX6u8mSfLp8K/OHzY2XagnRRgrodjYH+7rTsgJXpCNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Unit of work\"\n        title=\"Unit of work\"\n        src=\"/static/3cf3c2c84113cd99aeca5ea39731cac1/5a190/unit-of-work.png\"\n        srcset=\"/static/3cf3c2c84113cd99aeca5ea39731cac1/772e8/unit-of-work.png 200w,\n/static/3cf3c2c84113cd99aeca5ea39731cac1/e17e5/unit-of-work.png 400w,\n/static/3cf3c2c84113cd99aeca5ea39731cac1/5a190/unit-of-work.png 800w,\n/static/3cf3c2c84113cd99aeca5ea39731cac1/c1b63/unit-of-work.png 1200w,\n/static/3cf3c2c84113cd99aeca5ea39731cac1/29007/unit-of-work.png 1600w,\n/static/3cf3c2c84113cd99aeca5ea39731cac1/7970d/unit-of-work.png 1908w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>유닛오브워크는 <code>DbContext</code>를 감춘다. <code>DbContext</code>에 접근한다는 의미는 데이터베이스 조작에 필요한 모든 것을 할 수 있다는 의미이기 때문에 이런 위험을 유닛오브워크를 통해 예방할 수 있다. 아래에 간단한 구현 내용이 있다.</p>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">public interface IUnitOfWork : IDisposable\r\n{\r\n    ISiteRepository Sites { get; }\r\n    ICampaignRepository Campaigns { get; }\r\n    \r\n    Task&lt;int&gt; SaveChangesAsync();\r\n}\r\n\r\npublic class UnitOfWork : IUnitOfWork\r\n{\r\n    private readonly ApplicationContext context;\r\n    public ISiteRepository Sites { get; }\r\n    public ICampaignRepository Campaigns { get; }\r\n\r\n    public UnitOfWork(ApplicationContext context)\r\n    {\r\n        this.context = context;\r\n\r\n        Sites = new SiteRepository(context);\r\n        Campaigns = new CampaignRepository(context);\r\n    }\r\n    \r\n    public Task&lt;int&gt; SaveChangesAsync()\r\n    {\r\n        return context.SaveChangesAsync();\r\n    }\r\n\r\n    public void Dispose()\r\n    {\r\n        context?.Dispose();\r\n    }\r\n}</code>\n        </deckgo-highlight-code>\n<p>아래는 단위 테스트의 한 가지 예다. <code>CreateCampaignCommand</code>를 통해 <code>Campaign</code>을 생성하면서 <code>Proposal</code> 엔티티도 걑이 생성하고 있는지 확인하는 테스트다. 리포지토리와 유닛오브워크를 모킹하고 서로 연결한 후, 기대하는 리포지토리 메서드가 호출됐는지, 마지막으로 유닛오브워크의 <code>SaveChangesAsync()</code> 메서드가 호출되었는지 확인한다.</p>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">public class CreateCampaignCommandTests\r\n{\r\n    [Fact]\r\n    public async Task ShouldCreateCampaign()\r\n    {\r\n        var campaignRepo = new Mock&lt;ICampaignRepository&gt;();\r\n        var uow = new Mock&lt;IUnitOfWork&gt;();\r\n        uow.Setup(u =&gt; u.Campaigns).Returns(campaignRepo.Object);\r\n\r\n        var command = new CreateCampaignCommand{ Title = &quot;Test Campaign&quot;};\r\n        var sut = new CreateCampaignCommand.Handler(uow.Object);\r\n\r\n        await sut.Handle(command, CancellationToken.None);\r\n\r\n        campaignRepo.Verify(cr =&gt; cr.AddAsync(It.IsAny&lt;Campaign&gt;()), Times.Once);\r\n        campaignRepo.Verify(cr =&gt; cr.AddProposalAsync(It.IsAny&lt;Proposal&gt;()), Times.Once());\r\n        uow.Verify(u =&gt; u.SaveChangesAsync());\r\n    }\r\n}</code>\n        </deckgo-highlight-code>\n<h2>애그리게이트 루트 (Aggregate root)</h2>\n<p>리포지토리 개념에서 애그리게이트는 관련된 엔티티의 집합이며 루트는 그 엔티티중에 대표적인 엔티티를 일컫는다. <code>Order</code>와 그에 속한 <code>LineItem</code>을 다루면서 각각의 리포지토리를 사용하는 것보다는 <code>Order</code>를 통해 <code>LineItem</code>까지 관리하는 것이 합리적이다.</p>\n<p>아래 다이어그램은 <code>Station</code> 엔티티가 <code>SalesHouse</code>를 포함하면서 그 것에 대한 메서드를 품고 있는 것을 보여준다. <code>IStationRepository</code>는 제네릭 리포지토리에서 상속하는 메서드 외에 <code>SalesHouse</code>를 위한 추가적인 세 개의 메서드를 정의하고 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b5cb35731f88a7e0b680cfbddeefb3b2/81ebd/aggregate-root.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABoElEQVQ4y3WT14rCYBCFff93Ui8EwYK9gXqhoFgTN7bEdpZv1pEo68CQv5z/TDmTTJJcdDqddDgctN/vbZ0kiR6PhzkWJ4mOx6PiODYHh4Njfz6fdb1eDZv5iSJFUaRCoaBsNqvFYmGk9/tdbgTjETYejw2Xy+U0nU7tjDsCGuFut9NoNNJgMNBwONR2u9VqtTISopMFZ71eT51OR41GQ7VaTc1mU61WS91u14KQsRGGYah8Pq9yuWwPKZNoEN1uN9sDhqRYLKper6tarapSqRghCYHzCjJkET3LhhwiSvb+WQ/j2DImEHfggiAwksvlTwMwRuiP6Jn3wc1J+XKPs+YxWPaI4ZUYoS/SaacVTmeaNvCfBjaTJqDc9N7Jzs9xIRtKp9fr9drWlMwd39fY4CiNkvQHYNrWm43m87mRtNttExBhmArwTAXiGGEQhiY7ZP1+36Ivl0tT1gc5DAMjnEwmms1mJoj3jazBIMzb2JRKJcsA87/AhaC333rpLXqpDBhSJ2H/OTbs6RHkZJZ2znzU3sbmW2TMZ41g/7kHhPAXaqnnvfC8fxcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Aggregate root\"\n        title=\"Aggregate root\"\n        src=\"/static/b5cb35731f88a7e0b680cfbddeefb3b2/5a190/aggregate-root.png\"\n        srcset=\"/static/b5cb35731f88a7e0b680cfbddeefb3b2/772e8/aggregate-root.png 200w,\n/static/b5cb35731f88a7e0b680cfbddeefb3b2/e17e5/aggregate-root.png 400w,\n/static/b5cb35731f88a7e0b680cfbddeefb3b2/5a190/aggregate-root.png 800w,\n/static/b5cb35731f88a7e0b680cfbddeefb3b2/c1b63/aggregate-root.png 1200w,\n/static/b5cb35731f88a7e0b680cfbddeefb3b2/29007/aggregate-root.png 1600w,\n/static/b5cb35731f88a7e0b680cfbddeefb3b2/81ebd/aggregate-root.png 1868w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>여기서 한 단계 더 깊이 생각해 볼 필요가 있는데, 단순히 하나의 <code>Station</code>만 조회하던 <code>GetByIdAsync(id)</code>가 <code>SalesHouse</code>를 포함하는 오브젝트 그래프를 반환해야 한다는 점이다. <code>GetByIdAsync(id)</code>를 다시 구현하면서 <code>new</code> 키워드로 제넥릭 메서드를 무시할 수 있다.</p>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">// StationRepository.cs\r\npublic new async Task&lt;Station&gt; GetByIdAsync(int id)\r\n{\r\n    var station = await context.Stations\r\n        .Include(s =&gt; s.SalesHouse)\r\n        .SingleOrDefaultAsync(s =&gt; s.Id == id);\r\n    \r\n    if (station == null) throw new EntityNotFoundException(&quot;Station&quot;, id);\r\n    \r\n    return station;\r\n}</code>\n        </deckgo-highlight-code>\n<h2>결론</h2>\n<p>리포지토리-유닛오브워크 패턴이 DbSet-DbContext에 실행을 위임하고 있기 때문에 이 패턴이 과연 유용한 건지에 대한 의문이 여전히 존재한다. [리포지토리 패턴과 엔티티 프레임워크 코어](리포지토리 패턴과 엔티티 프레임워크 코어) 글을 통해 일부 장점을 살펴봤지만 꼭 사용해야 한다는 의미는 아니다. 이 패턴을 더 이상 사용하지 않는다는 <a href=\"https://www.thereformedprogrammer.net/\">John Smith의 블로그</a>를 통해 많은 인사이트를 얻을 수도 있다.</p>\n<p>만약 패턴을 사용하기로 결정했다면 이 글에서 소개한 제네릭 리포지토리를 통해 코드 중복을 줄이자. 또한, 유연한 상속구조를 통해 애그리게이트를 쉽게 구현할 수 있으니 좀더 DDD스러운 엔티티를 관리할 수 있을 것이다.</p>","frontmatter":{"title":"제네릭 리포지토리","keywords":"generic"}}},"pageContext":{"slug":"/제네릭-리포지토리/"}},"staticQueryHashes":["3159585216"]}